# crypto - six seven again

```
n = 3251607813085177983301975625605323741375065025290152043432568055099764874344422830511690778934813879861566162422819941279117877847941089614453273157857503062063608618399330087632536957442228437196650103547929146583058627296048343880732152249185046258982457119861396201200505768025241633644764791130463410030639664871749214571551884239378758541837028460450218864015062874761239925123873333214694407218907
c = 52309583566950455864459863823475826816155937890706714715288454406132191796624961200546162075591268371781317398395694521364768175015453214492206788033997543688977091755288593870288630688599838865147191078560128918423897549241184167656052165654750022269435245756530301473975830307727920532484943342770404252607631502317924794654116991886979380043624378579054179171084252461021065213265730603648677820720

A = Integer(int("6"*67))
B = Integer(int("7"*67))
base = Integer(10)**67
e = 65537

Z = Zmod(n)
PR.<x> = PolynomialRing(Z)

const = A*base^2 + B
inv_base = inverse_mod(base, n)

# monic polynomial
f = (base*x + const) * inv_base    # => x + const/base  (mod n)

# p is ~670 bits, n is ~1340 bits => beta slightly under 0.5
roots = f.small_roots(X=base, beta=0.49, epsilon=0.02)

print("roots:", roots)
if not roots:
    print("no roots; try beta=0.48 or epsilon=0.01/0.05")
    raise SystemExit

x0 = Integer(roots[0])

p = A*base^2 + x0*base + B
if n % p != 0:
    print("candidate didn't divide n; try next root / tweak params")
    raise SystemExit

q = n // p
phi = (p-1)*(q-1)
d = inverse_mod(e, phi)
m = pow(c, d, n)

hh = hex(Integer(m))[2:]
if len(hh) % 2: hh = "0"+hh
print(bytes.fromhex(hh))

# optional structure check:
s = str(p)
print(s[:67], s[-67:])
```

Flag: `lactf{n_h4s_1337_b1ts_b3c4us3_667+670=1337}`

SOLVED by Ha1qal

Solved by: yappare